"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[634],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(a),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||r;return a?n.createElement(u,s(s({ref:t},c),{},{components:a})):n.createElement(u,s({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5500:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={},s="Static Analysis",o={unversionedId:"Binary Analysis/Static Analysis/Reading/README_2",id:"Binary Analysis/Static Analysis/Reading/README_2",title:"Static Analysis",description:"Table of Contents",source:"@site/docs/Binary Analysis/Static Analysis/Reading/README_2.md",sourceDirName:"Binary Analysis/Static Analysis/Reading",slug:"/Binary Analysis/Static Analysis/Reading/README_2",permalink:"/binary-security/Binary Analysis/Static Analysis/Reading/README_2",draft:!1,tags:[],version:"current",frontMatter:{}},l={},p=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Linear Sweep",id:"linear-sweep",level:2},{value:"Recursive Traversal",id:"recursive-traversal",level:2},{value:"IDA tips &amp; tricks",id:"ida-tips--tricks",level:2},{value:"IDA Pro and Ghidra",id:"ida-pro-and-ghidra",level:2},{value:"04. crypto_crackme",id:"04-crypto_crackme",level:2},{value:"05. broken",id:"05-broken",level:2},{value:"06. hyp3rs3rv3r",id:"06-hyp3rs3rv3r",level:2}],c={toc:p},d="wrapper";function h(e){let{components:t,...r}=e;return(0,i.kt)(d,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"static-analysis"},"Static Analysis"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#disassembling-executables"},"Disassembling executables"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#linear-sweep"},"Linear Sweep")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#recursive-traversal"},"Recursive Traversal")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ida-and-ghidra"},"IDA and Ghidra"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ida-tips--tricks"},"IDA tips ","&"," tricks")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ida-pro-and-ghidra"},"IDA Pro and Ghidra")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#c"},"C++")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#further-reading"},"Further reading")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#challenges"},"Challenges"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#04-crypto_crackme"},"04. crypto_crackme")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#05-broken"},"05. broken")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#06-hyp3rs3rv3r"},"06. hyp3rs3rv3r"))))),(0,i.kt)("h1",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Sometimes we are either unable or reluctant to run an unknown executable. This inability to run the file can be caused by a multitude of factors, such as not having the correct dependencies or runtimes for it. In addition, it is often unsafe to run binaries without analysing them first. Today we'll learn about one method of analysis, called ",(0,i.kt)("strong",{parentName:"p"},"static analysis"),"."),(0,i.kt)("p",null,"Thus, static analysis allows us to understand the behaviour of the application by displaying either its assembly code or an equivalent high-level code. In order to obtain the assembly code, via a procedure called ",(0,i.kt)("strong",{parentName:"p"},"disassembling"),", currently there are two approaches being used, which we'll describe in the following sections. The high-level code, is ",(0,i.kt)("em",{parentName:"p"},"deduced")," from the machine code, through a more complex process called ",(0,i.kt)("strong",{parentName:"p"},"decompilation"),", which sometimes might make it a bit inaccurate, when compared to the assembly code."),(0,i.kt)("h1",{id:"disassembling-executables"},"Disassembling executables"),(0,i.kt)("p",null,"There are two main strategies when it comes to disassembly. They are called ",(0,i.kt)("strong",{parentName:"p"},"Linear Sweep")," and ",(0,i.kt)("strong",{parentName:"p"},"Recursive Traversal"),". As we'll see below, the main difference between the two is their accuracy"),(0,i.kt)("h2",{id:"linear-sweep"},"Linear Sweep"),(0,i.kt)("p",null,"The first strategy that we'll look at is ",(0,i.kt)("em",{parentName:"p"},"Linear Sweep"),". A very popular tool that uses this strategy is ",(0,i.kt)("inlineCode",{parentName:"p"},"objdump"),". What ",(0,i.kt)("em",{parentName:"p"},"Linear Sweep")," does is it parses the ",(0,i.kt)("inlineCode",{parentName:"p"},".text")," section of the executable from the beginning to the end and translates each encountered machine code instruction into its equivalent Assembly instruction. It's a fast and simple algorithm. Being so simple, however, renders it vulnerable to being mislead. This can happen in a few ways. One way is to insert an inappropriate instruction somewhere in the ",(0,i.kt)("inlineCode",{parentName:"p"},".text")," section. When the algorithm reaches it, it will try to interpret it as something meaningful and output a completely different Assembly code that would make no sense."),(0,i.kt)("p",null,"Let's consider the code below, which is also available ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/blob/master/sessions/04-static-analysis/activities/01-tutorial-disassemble-methods/src/wrong.c"},"in this repo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'int main()\n{\n    asm volatile(\n        "A: jmp B\\n\\t"\n        ".byte 0xde\\n\\t"\n        ".byte 0xad\\n\\t"\n        ".byte 0xc0\\n\\t"\n        ".byte 0xde\\n\\t"\n        "jmp -1\\n\\t"\n        "B:\\n\\t"\n    );\n    printf("What is wrong with me :-s?\\n");\n    return -1;\n}\n')),(0,i.kt)("p",null,"Take a look at the Makefile rule for ",(0,i.kt)("inlineCode",{parentName:"p"},"wrong")," and notice that it ",(0,i.kt)("strong",{parentName:"p"},"strips")," the binary:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-makefile"},"wrong: wrong.o\n    $(CC) $(CFLAGS) $< -o $@\n    -strip $@\n")),(0,i.kt)("p",null,"If we remove the line at the end of the snipped above and then disassemble the executable, we can see our inline assembly code (",(0,i.kt)("inlineCode",{parentName:"p"},"de ad c0 de"),") together with the encoding of ",(0,i.kt)("inlineCode",{parentName:"p"},"jmp -1"),". The binary code is as expected, but the way it's interpreted is completely off. This happens because ",(0,i.kt)("em",{parentName:"p"},"objdump"),' gets "confused" when reaching the bytes ',(0,i.kt)("inlineCode",{parentName:"p"},"de ad c0 de")," and can't figure out that that code is meaningless."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-asm"},"080491ab <A>:\n 80491ab:       eb 09                   jmp    80491b6 <B>\n 80491ad:       de ad c0 de e9 49       fisubr WORD PTR [ebp+0x49e9dec0]\n 80491b3:       6e                      outs   dx,BYTE PTR ds:[esi]\n 80491b4:       fb                      sti\n 80491b5:       f7                      .byte 0xf7\n\n080491b6 <B>:\n 80491b6:       83 ec 0c                sub    esp,0xc\n")),(0,i.kt)("p",null,"If we restore the line where the binary is stripped, recompile and disassemble it once more, we see that this time, ",(0,i.kt)("inlineCode",{parentName:"p"},"objdump")," gets completely lost when it encounters our ",(0,i.kt)("inlineCode",{parentName:"p"},"de ad c0 de")," sequence. This is because, previously, it used symbols in the binary, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", to figure out where some of the real instructions started. Now, without the help of those symbols, ",(0,i.kt)("inlineCode",{parentName:"p"},"objdump")," doesn't manage to output a coherent Assembly code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-asm"}," 804840c:       eb 09                   jmp    8048417 <__libc_start_main@plt+0x127>\n 804840e:       de ad c0 de e9 e8       fisubr WORD PTR [ebp-0x17162140]\n 8048414:       7b fb                   jnp    8048411 <__libc_start_main@plt+0x121>\n 8048416:       f7 83 ec 0c 68 c0 84    test   DWORD PTR [ebx-0x3f97f314],0xe8080484\n 804841d:       04 08 e8\n 8048420:       ac                      lods   al,BYTE PTR ds:[esi]\n 8048421:       fe                      (bad)\n 8048422:       ff                      (bad)\n 8048423:       ff 83 c4 10 b8 ff       inc    DWORD PTR [ebx-0x47ef3c]\n 8048429:       ff                      (bad)\n 804842a:       ff                      (bad)\n 804842b:       ff 8b 4d fc c9 8d       dec    DWORD PTR [ebx-0x723603b3]\n 8048431:       61                      popa\n 8048432:       fc                      cld\n 8048433:       c3                      ret\n")),(0,i.kt)("p",null,"In order to avoid traps like the one showcased above, we need to use smarter disassembly techniques, such as ",(0,i.kt)("em",{parentName:"p"},"Recursive Traversal"),"."),(0,i.kt)("h2",{id:"recursive-traversal"},"Recursive Traversal"),(0,i.kt)("p",null,"Note that, in the example above, the misleading instruction is never executed. If it were, the program would crash after receiving a ",(0,i.kt)("inlineCode",{parentName:"p"},"SIGILL")," signal and after outputting ",(0,i.kt)("inlineCode",{parentName:"p"},"Illegal instruction (core dumped)"),", because the CPU would not know how to decode that particular instruction. But if we run the binary above, we notice that it doesn't crash. So that instruction is nothing but dead code. As a result, it's useless to us no matter what it means. And this is where ",(0,i.kt)("em",{parentName:"p"},"Recursive Traversal")," comes in."),(0,i.kt)("p",null,"This strategy doesn't start the disassembly at the beginning of the ",(0,i.kt)("inlineCode",{parentName:"p"},".text")," section, but at the entry point (the address of the ",(0,i.kt)("inlineCode",{parentName:"p"},"_start")," symbol) and disassembles the instructions linearly, while also considering ",(0,i.kt)("strong",{parentName:"p"},"jumps"),". Thus, when encountering code branches, the algorithm follows them and creates what's called a ",(0,i.kt)("strong",{parentName:"p"},"Control Flow Graph (CFG)"),", where each node is called a ",(0,i.kt)("strong",{parentName:"p"},"Basic Block (BB)")," and is made up of instructions that are always executed in that order, regardless of conditional jumps or function calls. Take a look at the CFG below and note the BBs and the jumps that make up the arches. The code comes from the ",(0,i.kt)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary, which can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/tree/master/sessions/04-static-analysis/activities/02-tutorial-ida-time/src"},"here"),". To make things harder, this executable was also stripped.\n",(0,i.kt)("img",{alt:"CFG created by IDA",src:a(183).Z,width:"400",height:"583"})),(0,i.kt)("p",null,"In conclusion, we can look at the CFG as being a DFS (recursive) traversal of the code, separated into BBs, with ",(0,i.kt)("inlineCode",{parentName:"p"},"ret")," instructions acting as ",(0,i.kt)("em",{parentName:"p"},"back edges"),"."),(0,i.kt)("h1",{id:"ida-and-ghidra"},"IDA and Ghidra"),(0,i.kt)("p",null,"The tool that we used in order to generate the image above is called ",(0,i.kt)("a",{parentName:"p",href:"https://www.hex-rays.com/products/ida/support/download_freeware/"},"IDA"),". Next, we'll learn how to use it!"),(0,i.kt)("p",null,"We'll showcase the functionalities of IDA by disassembling the ",(0,i.kt)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary. The first screen you are presented with is the following:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"Initial IDA Screen",src:a(5061).Z,width:"600",height:"396"})),(0,i.kt)("p",null,"Main components:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"On the left you have the ",(0,i.kt)("strong",{parentName:"li"},"Function window")," with the list of identified subroutines, functions or external functions called by the binary. They are color coded according to the legend right above it."),(0,i.kt)("li",{parentName:"ul"},"Under it you have a graph overview of the view presented on the right."),(0,i.kt)("li",{parentName:"ul"},"On the right you have multiple tabs, with the ",(0,i.kt)("strong",{parentName:"li"},"Function summary")," selected in the IDA-view. We will not be using this. Instead, we will switch to the complete ",(0,i.kt)("strong",{parentName:"li"},"Graph View")," of functions by pressing the spacebar. This graph is the CFG we mentioned earlier.")),(0,i.kt)("p",null,"Upon pressing spacebar and navigating in the ",(0,i.kt)("strong",{parentName:"p"},"Function window")," to functions that are not coloured (meaning they are part of this binary) we get the following view:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"IDA - First View",src:a(4970).Z,width:"600",height:"241"})),(0,i.kt)("p",null,"When reversing binaries, we will see this particular Assembly construct a lot, as it is the standard one generated by ",(0,i.kt)("inlineCode",{parentName:"p"},"gcc"),". Remember from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/tree/master/sessions/03-executable-file-formats"},"Session 02")," that ",(0,i.kt)("a",{parentName:"p",href:"refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html"},"_","_","libc_start_main")," is the wrapper that calls ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),". We now rename the last argument pushed on the stack to main. Press ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," and enter the new name. Now you have your first function identified. Click on it to see what ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," does:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"main",src:a(4035).Z,width:"600",height:"348"})),(0,i.kt)("p",null,"Note how the execution is neatly layed out in the CFG view. If you look at the left panel you can see the complete view. The execution is divided because of conditional and unconditional branches. Let's figure out what happens by analyzing the assembly code:"),(0,i.kt)("p",null,"First we have the function prologue, stack alignment and stack allocation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-asm"},"push    ebp\nmov     ebp, esp\nand     esp, 0FFFFFFF0h\nsub     esp, 450h\n")),(0,i.kt)("p",null,"Next, a variable on the stack is initialized to 1. If you click on ",(0,i.kt)("inlineCode",{parentName:"p"},"434h")," it will become highlighted and you can scroll through the whole function to see where it's used later. We'll ignore this for now."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-asm"},"mov     dword ptr [esp+434h], 1\n")),(0,i.kt)("p",null,"Next, we see the first branching:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"cmp     [ebp+arg_0], 2\njz      short loc_8049068\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Remember!")),(0,i.kt)("p",null,"On 32 bit systems, ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp + 0]")," is the saved ",(0,i.kt)("inlineCode",{parentName:"p"},"ebp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp + 4]")," is the return address and ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp + 8]")," is the first argument to the current function. IDA follows a slightly different naming convention: ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp + 8]")," is named ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp+arg_0]"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp + 12]")," is named ",(0,i.kt)("inlineCode",{parentName:"p"},"[ebp+arg_4]")," etc. You can rename those ",(0,i.kt)("inlineCode",{parentName:"p"},"arg_*")," constructs if you want, anyway."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"So it's referring to the first argument: ",(0,i.kt)("inlineCode",{parentName:"p"},"argc"),". Basically, what it does is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if(argc == 2) {\n    goto loc_8049068\n} else {\n....\n}\n")),(0,i.kt)("p",null,"What does the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch do?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-asm"},'mov     eax, [ebp+arg_4]\nmov     eax, [eax]\nmov     [esp+4], eax\nmov     dword ptr [esp], offset format ; "Usage: %s <banner_file>\\n"\ncall    _printf\n\nmov     dword ptr [esp], 0 ; status\ncall    _exit\n')),(0,i.kt)("p",null,"It's pretty straightforward if you remember the tasks from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/tree/master/sessions/03-executable-file-formats"},"Session 02"),". The second argument (",(0,i.kt)("inlineCode",{parentName:"p"},"argv"),") is dereferenced and pushed on the stack along with a format string. Then ",(0,i.kt)("inlineCode",{parentName:"p"},"printf")," is called. Next, ",(0,i.kt)("inlineCode",{parentName:"p"},"exit")," is called with a status of 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'if(argc == 2) {\n    goto loc_8049068\n} else {\n    printf("%s <banner_file>\\n", argv[0]);\n    exit(0);\n}\n')),(0,i.kt)("p",null,"Now let's do something a bit more advanced: we want to identify the 2 commands that the server accepts by using static analysis. How do we approach this problem as fast as possible? We already know that the server accepts multiple clients. It can do this through forking. Let's see where ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," is called in the program. First find the ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," function on the left panel and select it. Now you see a stub to it from the ",(0,i.kt)("inlineCode",{parentName:"p"},"PLT")," section. We want to find all locations in the program that call this function. You can achieve this by obtaining all the ",(0,i.kt)("strong",{parentName:"p"},"cross-references (xrefs)")," to it by pressing ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". You should get the following screen:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"fork cross-references 1",src:a(3692).Z,width:"600",height:"347"})),(0,i.kt)("p",null,"Click that location and you will get to the forking point:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"fork cross-references 2",src:a(183).Z,width:"400",height:"583"})),(0,i.kt)("p",null,"You can see that the return value is stored on the stack at ",(0,i.kt)("inlineCode",{parentName:"p"},"[esp+438h]"),", some error checking (",(0,i.kt)("inlineCode",{parentName:"p"},"perror")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"exit"),") is done and then the return value is checked for 0 (as we traditionally do for ",(0,i.kt)("inlineCode",{parentName:"p"},"fork")," calls). The child will execute ",(0,i.kt)("inlineCode",{parentName:"p"},"sub_8048ED7")," and the parent will loop back. You can rename ",(0,i.kt)("inlineCode",{parentName:"p"},"sub_8048ED7")," to something more legible such as ",(0,i.kt)("inlineCode",{parentName:"p"},"handle_child_process"),"\nIn this function you can now clearly see the two commands and which function is called for each:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"handle_child_process",src:a(8051).Z,width:"600",height:"571"})),(0,i.kt)("p",null,"It looks like the one on the left, ",(0,i.kt)("inlineCode",{parentName:"p"},"sub_8048B0B")," handles the ",(0,i.kt)("inlineCode",{parentName:"p"},"LIST")," command so we rename it to ",(0,i.kt)("inlineCode",{parentName:"p"},"handle_LIST"),". As expected, it calls ",(0,i.kt)("inlineCode",{parentName:"p"},"opendir")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"readdir")," to read all the files in the current directory, then writes them to the socket.",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"handle_LIST",src:a(9287).Z,width:"400",height:"539"})),(0,i.kt)("h2",{id:"ida-tips--tricks"},"IDA tips & tricks"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Saving progress is disabled for the trial version. However, you can save a limited (but useful) subset of your work using ",(0,i.kt)("inlineCode",{parentName:"li"},"File -> Produce File -> Dump database to IDC file")," and then load it next time using ",(0,i.kt)("inlineCode",{parentName:"li"},"File -> Script File"),"."),(0,i.kt)("li",{parentName:"ul"},"If you close some windows and don't know how to get them back you can reset the layout using ",(0,i.kt)("inlineCode",{parentName:"li"},"Windows->Reset Desktop"),"."),(0,i.kt)("li",{parentName:"ul"},"If you want to return to the previous view you can press ",(0,i.kt)("inlineCode",{parentName:"li"},"Escape"),"."),(0,i.kt)("li",{parentName:"ul"},"When you want to view code as in ",(0,i.kt)("inlineCode",{parentName:"li"},"objdump")," you only need to press ",(0,i.kt)("inlineCode",{parentName:"li"},"Spacebar")," once. And then again to return to CFG mode."),(0,i.kt)("li",{parentName:"ul"},"If there is a hex value and you want to convert it to decimal (or back) press ",(0,i.kt)("inlineCode",{parentName:"li"},"h"),"."),(0,i.kt)("li",{parentName:"ul"},"Converting hex/dec values to ",(0,i.kt)("em",{parentName:"li"},"ASCII"),": press ",(0,i.kt)("inlineCode",{parentName:"li"},"r"),"."),(0,i.kt)("li",{parentName:"ul"},"If you want to write comments next to an instruction or a function press ",(0,i.kt)("inlineCode",{parentName:"li"},":"),".")),(0,i.kt)("h2",{id:"ida-pro-and-ghidra"},"IDA Pro and Ghidra"),(0,i.kt)("p",null,"IDA Pro is installed on the Kali virtual machine. The main difference between it and the free version is that the Pro one can also ",(0,i.kt)("strong",{parentName:"p"},"decompile")," the code based on the CFGs listed above. This will come in extremely useful as we hack more and more binaries."),(0,i.kt)("p",null,"Another tool that is capable of decompiling the code in an executable is ",(0,i.kt)("a",{parentName:"p",href:"https://ghidra-sre.org/"},"Ghidra"),". One advantage of Ghidra over IDA is that Ghidra displays both the C and the Assembly code side by side. This allows us to correlate the two and reap the benefits of both of them at the same time."),(0,i.kt)("h1",{id:"c"},"C++"),(0,i.kt)("p",null,"Things look slightly different when we try to hack executables that have been compiled from C++ code, instead of C. The difference comes from the way symbols (method symbols in particular) are handled by C++ compilers. Let's disassemble the code below and see how its symbols look:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-code",metastring:"c",c:!0},'#include <iostream>\nusing namespace std;\nint main()\n{\n    cout << "Hello world" << endl;\n    return 0;\n}\n')),(0,i.kt)("p",null,"Disassembling it in IDA looks familiar at first\n",(0,i.kt)("img",{alt:"IDA _start",src:a(5474).Z,width:"400",height:"379"})),(0,i.kt)("p",null,"But then the fun starts:\n",(0,i.kt)("img",{alt:"IDA main",src:a(354).Z,width:"550",height:"343"})),(0,i.kt)("p",null,"As we can see, all symbols look almost as if they were encrypted. In fact, this process is called ",(0,i.kt)("strong",{parentName:"p"},"name mangling"),". If we take a closer look at them, however, we can distinguish some clues about those function calls, for example. The first one contains the sequences ",(0,i.kt)("inlineCode",{parentName:"p"},"char_traits")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"basic_ostream"),", the former being a C++ abstraction for string operations, while the latter is a base class for output operators, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"<<"),"."),(0,i.kt)("p",null,"IDA can demangle strings such as the ones above by itself. Some recommended settings (you may prefer something different) are the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Options -> Demangled names")),(0,i.kt)("li",{parentName:"ul"},"Show demangled C++ names as ",(0,i.kt)("inlineCode",{parentName:"li"},"Names")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Setup short names")),(0,i.kt)("li",{parentName:"ul"},"Click ",(0,i.kt)("inlineCode",{parentName:"li"},"Only main name"))),(0,i.kt)("p",null,"These settings only display the important classes and namespaces that make up each method, like this:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"IDA demangled",src:a(9345).Z,width:"521",height:"416"})),(0,i.kt)("h1",{id:"further-reading"},"Further reading"),(0,i.kt)("p",null,"More information about name mangling can be obtained at:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Name_mangling"},"https://en.wikipedia.org/wiki/Name_mangling")),(0,i.kt)("li",{parentName:"ul"},"on demand demangling: ",(0,i.kt)("a",{parentName:"li",href:"http://demangler.com/"},"http://demangler.com/")," or c++filt")),(0,i.kt)("p",null,"You can find out more information about the internals of C++ in general, using the following references:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ocw.cs.pub.ro/courses/cpl/labs/06"},"https://ocw.cs.pub.ro/courses/cpl/labs/06")," (in Romanian)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf"},"https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf"},"http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf"))),(0,i.kt)("h1",{id:"challenges"},"Challenges"),(0,i.kt)("h2",{id:"04-crypto_crackme"},"04. crypto_crackme"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"crypto_crackme")," binary is an application that asks for a secret and uses it to decrypt a message. In order to solve this task, you have to retrieve the message."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Open the binary using IDA and determine the program control flow. What is it doing after fetching the secret? It seems to be consuming a lot of CPU cycles. If possible, use IDA to patch the program and reduce the execution time of the application. Use ''Edit -> Patch program -> Change byte...''"),(0,i.kt)("li",{parentName:"ul"},"Next, it looks like the program tries to verify if the secret provided is correct. Where is the secret stored? Is it stored in plain text? Find out what the validation algorithm is."),(0,i.kt)("li",{parentName:"ul"},"Now break it and retrieve the message!")),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Important!")),(0,i.kt)("p",null,"Unfortunately, the virtual machine doesn't support the libssl1.0.0 version of SSL library. Use the library files in the task archive and run the executable using:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"LD_LIBRARY_PATH=. ./crypto_crackme\n")),(0,i.kt)("p",null,"You can break password hashes (including SHA1) on ",(0,i.kt)("a",{parentName:"p",href:"https://crackstation.net/"},"CrackStation"),"."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"05-broken"},"05. broken"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"broken")," binary is asking you for the correct password. Investigate the binary and provide it with the correct password. If you provided the correct password the message ",(0,i.kt)("inlineCode",{parentName:"p"},"%%That's correct! The password is '...'%%"),"."),(0,i.kt)("h2",{id:"06-hyp3rs3rv3r"},"06. hyp3rs3rv3r"),(0,i.kt)("p",null,"Investigate the ",(0,i.kt)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary and find out where the backdoor function is. Note that since it's not directly called, IDA doesn't think of it as a procedure, so it won't come up on the left pane. Figure out a way around this. When you find that code block you can press ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," on the first instruction to help IDA see it as a procedure."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Tip"),(0,i.kt)("p",null,"In order to exploit the vulnerability in Ubuntu, you should use netcat-traditional. You can switch from netcat-openbsd to netcat-traditional using the steps described ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/10065993/how-to-switch-to-netcat-traditional-in-ubuntu"},"here"),".")))}h.isMDXComponent=!0},3692:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/fork_xref_1-85f1d0232651a1b8e0dc2df57af3979f.png"},183:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/fork_xref_2-cbbaaa29d6a79b16ccf9c7d72cc30a37.png"},9287:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/handle_LIST-eaf7cb36cd6f261db6c91508e7e0635a.png"},8051:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/handle_child_process-f520438be14ce78f7514ced2194469df.png"},9345:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_c++_demangled-849d03717ab1cd61335f6f35be59b9e6.png"},354:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_c++_main-07869074429c34f45c71bade45f6c02d.png"},5474:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_c++_start-e9f9ebb679d097cf91802b3850951f91.png"},4970:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_first_view-15240b5bcf4ffef9a1a20eea4decd16f.png"},5061:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_initial_screen-2ccb264922a514f0f40dbc43ea8dff4f.png"},4035:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ida_main-843538c9f43f8c93ebd5a3617728722e.png"}}]);